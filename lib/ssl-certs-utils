#!/bin/bash
# ================================================================================
# SSL cert management script for Let's Encrypt - Utils
#
# author: Axel Pardemann (axelitus)
# ================================================================================
declare -r TRUE=0 # Set TRUE constant (shell convention is 0 for no errors)
declare -r FALSE=1 # Set FALSE constant (shell convention is non-zero for errors)
declare -r EXIT_CODE_OK=0 # Set default exit code ok
declare -r EXIT_CODE_ERROR=1 # Set default exit code error
declare -r CERTBOT_PATH="/opt/certbot" # The path to the certbot-auto executable
declare -r CERTBOT_SYMLINK="/usr/bin/certbot-auto" # Set the path to the certbot symlink
declare -r CERTBOT_REPO="https://github.com/certbot/certbot" # Set the certbot repo address to clone
declare -r CONFIG_PATH="/etc/ssl-certs" # Set the configuration folder path
declare -r CONFIG_FILE="$CONFIG_PATH/ssl-certs.ini" # Set the main configuration file path
declare -r CONFIG_DOMAINS_PATH="$CONFIG_PATH/domains.d" # Set the individual domains config file path
declare -r CERT_PATH="/etc/ssl/domains" # Set the path where the certificates will be symlinked to
declare -r COLOR_RESET="\033[0m" # Set color reset code
declare -r COLOR_RED="\033[0;31m" # Set color red code
declare -r COLOR_GREEN="\033[0;32m" # Set color green code
declare -r COLOR_YELLOW="\033[0;33m" # Set color yellow code

# __certbot_exists()
# Verifies that certbot executable exists.
# Returns true if it exists, false otherwise.
# Sets the variable $certbot to the path of the executable.
__certbot_exists()
{
    certbot=$(which certbot-auto)
    if [ -z "$certbot" ]; then
        if [ -f "$CERTBOT_PATH/certbot-auto" ]; then
            certbot="$CERTBOT_PATH/certbot-auto"
            return $TRUE
        fi
        return $FALSE
    fi

    return $TRUE
}

# __certbot_or_fail(int exit code, string message)
# Verifies if certbot exists or script execution will fail.
# Sets the variable $certbot to the path of the executable.
__certbot_or_fail()
{
    exit_code=$1
    message=$2

    if [ -z "$exit_code" ]; then
        exit_code=$EXIT_CODE_ERROR
    fi

    __certbot_exists
    if [ $? -eq $FALSE ]; then
        echo "$message"
        exit $exit_code
    fi
}

# __concat_config_files($dest, $config1, $config2, ...)
# Concatenates the given config files into a destination file.
# Returns true 
__concat_config_files()
{
    echo
}

# __echo_repeat(string str, int num)
# Echoes multiple times the given string
__echo_repeat()
{
    local str num
    str=$1; num=$2

    if [ -z "$str" ]; then
        return
    fi

    if [ -z "$num" ]; then
        num=1
    fi

    repeated=$(printf "%-${num}s" "$str")
    echo "${repeated// /$str}"
}

# __ensure_folder(string path, integer mode)
# Verifies if folder exists, if not then it creates it with the given mode (or default if non given).
# Returns true if nothing failed, false otherwise.
__ensure_folder()
{
    local path mode
    path=$1; mode=$2

    if [ -z "$path" ]; then
        return $FALSE;
    fi

    __folder_exists "$path"
    if [ ! $? ]; then
        mkdir -p "$path"
        if [ ! $? ]; then
            return $FALSE
        else
            if [ -n "$mode" ]; then
                chmod "$mode" "$path"
                if [ ! $? ]; then
                    return $FALSE;
                fi
            fi
        fi
    fi

    return $TRUE
}

# __folder_exists(string path)
# Returns true if the given folder exists (and is not a symlink), false otherwise.
__folder_exists()
{
    local path
    path=$1

    if [ -z "$path" ]; then
        return $FALSE;
    fi

    if [[ -d "$path" && ! -L "$path" ]]; then
        return $TRUE
    else
        return $FALSE
    fi
}
